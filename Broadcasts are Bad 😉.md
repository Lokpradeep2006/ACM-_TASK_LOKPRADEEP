# Solving with Chinese Remainder Theorem (CRT)

I solved the problem using the Chinese Remainder Theorem (CRT) to combine the three ciphertexts under different moduli. After combining, I computed the integer cube root (since `e = 3`) to reveal the original message.

## Code Snippet

Below is the essential Python snippet that demonstrates the solution:

```python
from sympy.ntheory.modular import solve_congruence

congruences = [(ct1, n1), (ct2, n2), (ct3, n3)]
c, _ = solve_congruence(*congruences)

# Finding the plaintext by computing the cube root of c
p = int(round(c ** (1/3)))

Decrypted Plaintext
The resulting decrypted plaintext is:
42800643192345849658832356723113079698799922547523584
This concludes the successful decryption process.
Decipher: b'recr{H4s4d_is_t0_g00d}'

CODE :

from Crypto.Util.number import bytes_to_long, long_to_bytes
from Crypto import Random
import Crypto
import sys
import libnum

n1=93500162517048641546787096055793757535647246115573452820070426952722839105259206386726342320373080028589838409420934957286736144380948165832820988099621769638760228520922601557891245459269555695273287461982149159244732888497451549014876606240205619538734235283434466606740831016126239969278127395932813972501
n2=69389646088454519961777612972795170975757344514768971340015442739948594078401371455619333135568702919584689527569525412014628819453197654891812622405663009392306477333014587313114349970319506949532748028160803547659404882094671572233644067789871312676667284969540366763124836901936574299355649024020474292507
n3=173343492679580453099087472373077831318468581021117934856501363981932357178004338045575880395223727472909876082267313542279706329989182144352883996336740679533245920391761546352887945995038709117785508115723234046039796085997076590595344206748962306765136674210538263394651485897800900761481602355016363501601
c1=78406286729520927933597606356229817207730090348466337528850035686907731769583595879598630905387554797365268804265749503975166670245660278708562880234673953125
c2=78406286729520927933597606356229817207730090348466337528850035686907731769583595879598630905387554797365268804265749503975166670245660278708562880234673953125
c3=78406286729520927933597606356229817207730090348466337528850035686907731769583595879598630905387554797365268804265749503975166670245660278708562880234673953125

if (len(sys.argv)>1):
    c1=int(sys.argv[1])
if (len(sys.argv)>2):
    c2=int(sys.argv[2])
if (len(sys.argv)>3):
    c3=int(sys.argv[3])
if (len(sys.argv)>4):
    n1=int(sys.argv[4])
if (len(sys.argv)>5):
    n2=int(sys.argv[5])
if (len(sys.argv)>6):
    n3=int(sys.argv[6])                
e=3



mod=[n1,n2,n3]
rem=[c1,c2,c3]

res=libnum.solve_crt(rem,mod)

print("\n\nAnswer:")
print(f"\nCipher 1: {c1}, N1={n1}")
print(f"Cipher 2: {c2}, N2={n2}")
print(f"Cipher 3: {c3}, N3={n3}")


print(f"\nWe can solve M^e with CRT to get {res}")
val=libnum.nroot(res,3)
print(f"\nIf we assume e=3, we take the third root to get: {val}")
print("Next we convert this integer to bytes, and display as a string.")
print(f"\nDecipher: {long_to_bytes(val)}")
